# Spec: Agentic Unified Layer

## Overview

This specification defines the unified architecture for ACP Agent and DeepChat Agent, enabling the renderer process to interact with different agent types through a single, consistent interface.

## Background

### Current State

| Feature | ACP Agent | DeepChat Agent |
|---------|-----------|----------------|
| **Presenter** | `AcpPresenter` | `AgentPresenter` |
| **Session Management** | `SessionManager` (in-memory) | `SessionPresenter` (SQLite) |
| **Event System** | `ACP_EVENTS` | `STREAM_EVENTS` |
| **Persistence** | Agent-side (`loadSession` streams history) | SQLite persistence |
| **Process Model** | Independent Node.js process | Shared main process |
| **Tool Calling** | ACP protocol built-in | MCP + Agent tools |

### Problems

1. **Interface Fragmentation** - Renderer must distinguish agent types and call different presenters
2. **Event System Split** - Two event formats requiring separate frontend handling
3. **Session Semantics Mismatch** - ACP uses `sessionId` vs DeepChat uses `conversationId`

## Requirements

### Functional Requirements

#### REQ-1: Unified Interface
- **REQ-1.1**: Renderer shall use a single interface to interact with any agent type
- **REQ-1.2**: Agent type shall be identified by `agent_id` string
- **REQ-1.3**: The interface shall support session management, messaging, and control operations

#### REQ-2: Agent Identification
- **REQ-2.1**: Each agent shall have a unique `agent_id` following pattern: `<type>.<provider>.<name>`
- **REQ-2.2**: Supported agent types:
  - `deepchat.*` - DeepChat built-in agents
  - `acp.*` - ACP protocol agents
- **REQ-2.3**: Agent registration shall be automatic on application startup

#### REQ-3: Unified Session Management
- **REQ-3.1**: All agents shall use `sessionId` as the unified session identifier
- **REQ-3.2**: For DeepChat agents, `sessionId` shall map to `conversationId` from SQLite
- **REQ-3.3**: For ACP agents, `sessionId` shall be generated by the agent
- **REQ-3.4**: The system shall provide `loadSession(sessionId)` with agent-specific implementations:
  - ACP: Triggers streaming history push from agent
  - DeepChat: Loads from SQLite

#### REQ-4: Unified Event System
- **REQ-4.1**: All agents shall emit events in the `AgenticEventType` format
- **REQ-4.2**: Events shall cover:
  - Session lifecycle (created, updated, closed)
  - Message flow (delta, block, end)
  - Tool calls (start, running, end)
  - Status changes and errors
- **REQ-4.3**: Event normalization shall happen internally within each presenter

#### REQ-5: Model and Mode Selection
- **REQ-5.1**: The interface shall provide `setModel(sessionId, modelId)` for model selection
- **REQ-5.2**: The interface shall provide `setMode(sessionId, modeId)` for mode/permission policy selection
- **REQ-5.3**: `modeId` shall come from `availableModes` array returned by the agent
- **REQ-5.4**: Model configuration (temperature, maxTokens, etc.) shall NOT be handled at this layer

#### REQ-6: Extensibility
- **REQ-6.1**: New agent types shall be added by implementing `IAgenticPresenter` protocol
- **REQ-6.2**: New agent types shall register via `agentic.registerAgent(presenter)`

### Non-Functional Requirements

#### NFR-1: Separation of Concerns
- Model configuration shall NOT be handled by this layer
- Permission policy implementation shall remain within each agent
- Persistence strategies shall remain agent-specific

#### NFR-2: Type Safety
- All interfaces shall be fully typed with TypeScript
- No `any` types shall be used in public interfaces

#### NFR-3: Backward Compatibility
- This is a green-field design; no migration path required
- Existing ACP and DeepChat presenters shall be refactored to implement the new protocol

## Data Models

### SessionInfo

```typescript
interface SessionInfo {
  sessionId: string
  agentId: string
  status: 'idle' | 'generating' | 'paused' | 'error'

  // Available modes = available permission policy options
  availableModes?: Array<{ id: string; name: string; description: string }>

  // Available models
  availableModels?: Array<{ id: string; name: string; description?: string }>

  // Current selection
  currentModeId?: string
  currentModelId?: string

  // Capability declarations
  capabilities: {
    supportsVision: boolean
    supportsTools: boolean
    supportsModes: boolean
  }
}
```

### MessageContent

```typescript
interface MessageContent {
  text?: string
  images?: Array<{ type: 'url' | 'base64' | 'file'; data: string }>
  files?: Array<{ path: string; name: string }>
}
```

### SessionConfig

```typescript
interface SessionConfig {
  modelId?: string
  modeId?: string
  // Additional agent-specific config
  [key: string]: any
}
```

### LoadContext

```typescript
interface LoadContext {
  maxHistory?: number
  includeSystemMessages?: boolean
}
```

## API Specification

### IAgenticPresenter Protocol

```typescript
interface IAgenticPresenter {
  readonly agentId: string

  // Session management
  createSession(config: SessionConfig): Promise<string>
  getSession(sessionId: string): SessionInfo | null
  loadSession(sessionId: string, context: LoadContext): Promise<void>
  closeSession(sessionId: string): Promise<void>

  // Messaging
  sendMessage(sessionId: string, content: MessageContent): Promise<void>

  // Control
  cancelMessage(sessionId: string, messageId: string): Promise<void>

  // Model/Mode selection
  setModel(sessionId: string, modelId: string): Promise<void>
  setMode(sessionId: string, modeId): Promise<void>
}
```

### AgenticEventType Enum

```typescript
enum AgenticEventType {
  // Session lifecycle
  SESSION_CREATED = 'agentic.session.created',
  SESSION_UPDATED = 'agentic.session.updated',
  SESSION_CLOSED = 'agentic.session.closed',

  // Message flow
  MESSAGE_DELTA = 'agentic.message.delta',
  MESSAGE_BLOCK = 'agentic.message.block',
  MESSAGE_END = 'agentic.message.end',

  // Tool calls
  TOOL_START = 'agentic.tool.start',
  TOOL_RUNNING = 'agentic.tool.running',
  TOOL_END = 'agentic.tool.end',

  // Status
  STATUS_CHANGED = 'agentic.status.changed',
  ERROR = 'agentic.error',
}
```

## Event Payloads

### SESSION_CREATED

```typescript
interface SessionCreatedEvent {
  sessionId: string
  agentId: string
  sessionInfo: SessionInfo
}
```

### MESSAGE_DELTA

```typescript
interface MessageDeltaEvent {
  sessionId: string
  messageId: string
  content: string
  isComplete: boolean
}
```

### MESSAGE_BLOCK

```typescript
interface MessageBlockEvent {
  sessionId: string
  messageId: string
  blockType: 'text' | 'tool' | 'reasoning' | 'error'
  content: unknown
}
```

### TOOL_START

```typescript
interface ToolStartEvent {
  sessionId: string
  toolId: string
  toolName: string
  arguments: Record<string, unknown>
}
```

### STATUS_CHANGED

```typescript
interface StatusChangedEvent {
  sessionId: string
  status: 'idle' | 'generating' | 'paused' | 'error'
  error?: Error
}
```

## Architecture Constraints

### What This Layer Handles

| Feature | Scope |
|---------|-------|
| **Model Management** | Model ID selection only |
| **Mode Management** | Permission policy selection via `setMode(modeId)` |
| **History Loading** | Unified `loadSession` interface |
| **Agent Routing** | `agent_id` to Presenter mapping |

### What This Layer Does NOT Handle

| Feature | Responsibility |
|---------|---------------|
| **Model Configuration** | temperature, maxTokens, topP - handled by each agent |
| **Permission Policy Implementation** | Specific request handling - agent internal |
| **Persistence Strategy** | ACP streaming vs DeepChat SQLite - agent specific |
| **Session Storage** | DeepChat SQLite storage - AgentPresenter internal |

## Success Criteria

1. Renderer can interact with any agent using only `AgenticPresenter`
2. All agents emit events in `AgenticEventType` format
3. New agent types can be added without modifying renderer code
4. Type safety maintained throughout the stack
5. Existing ACP and DeepChat functionality preserved

## Open Questions

### [RESOLVED] Agent ID Format
**Question**: What format should `agent_id` use?

**Resolution**: Use hierarchical format `<type>.<provider>.<name>`
- Examples: `deepchat.default`, `acp.anthropic.claude-code`

### [RESOLVED] DeepChat Agent Modes
**Question**: What should `availableModes` contain for DeepChat agents?

**Resolution**: For DeepChat agents, `setMode` controls the **permission policy** (default permission judgment logic). The available modes are:

| Mode ID | Name | Description |
|---------|------|-------------|
| `strict` | Strict | All operations require user confirmation |
| `balanced` | Balanced | Read operations auto-allow, write/delete require confirmation |
| `permissive` | Permissive | Most operations auto-allow, only dangerous operations require confirmation |

**Design Notes**:
- `setMode(sessionId, modeId)` sets the session-level permission policy
- This affects how permission requests are handled for the entire session
- For example: in `balanced` mode, file read operations may be auto-approved, but file writes still prompt the user
- No per-tool remember mechanism exists (ACP agents have their own internal handling)
- Future extension: True "execution modes" (like ACP's plan/act) may be added later

### [RESOLVED] Event Normalization Approach
**Question**: Should we have a centralized EventNormalizer?

**Resolution**: No - each Presenter handles its own event conversion internally
- AgentPresenter: `STREAM_EVENTS` → `AgenticEventType`
- AcpPresenter: `ACP_EVENTS` → `AgenticEventType`

## Dependencies

### Internal Dependencies
- `src/main/presenter/agentPresenter/` - Must implement `IAgenticPresenter`
- `src/main/presenter/acpPresenter/` - Must implement `IAgenticPresenter`
- `src/main/eventbus.ts` - For unified event emission

### External Dependencies
- None (pure architecture layer)

## Related Documents

- Architecture: `docs/architecture/agent-abstraction-layer.md`
- Implementation Plan: `docs/specs/agentic-unified-layer/plan.md`
- Task Breakdown: `docs/specs/agentic-unified-layer/tasks.md`
