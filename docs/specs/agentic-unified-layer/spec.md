# Spec: Agentic Unified Layer

## Overview

This specification defines the unified architecture for ACP Agent and DeepChat Agent, enabling the renderer process to interact with different agent types through a single, consistent interface.

## Background

### Current State

| Feature | ACP Agent | DeepChat Agent |
|---------|-----------|----------------|
| **Presenter** | `AcpPresenter` | `AgentPresenter` |
| **Session Management** | `SessionManager` (in-memory) | `SessionPresenter` (SQLite) |
| **Event System** | `ACP_EVENTS` | `STREAM_EVENTS` |
| **Persistence** | Agent-side (`loadSession` streams history) | SQLite persistence |
| **Process Model** | Independent Node.js process | Shared main process |
| **Tool Calling** | ACP protocol built-in | MCP + Agent tools |

### Problems

1. **Interface Fragmentation** - Renderer must distinguish agent types and call different presenters
2. **Event System Split** - Two event formats requiring separate frontend handling
3. **Session Semantics Mismatch** - ACP uses `sessionId` vs DeepChat uses `conversationId`

## Requirements

### Functional Requirements

#### REQ-1: Unified Interface
- **REQ-1.1**: Renderer shall use a single interface to interact with any agent type
- **REQ-1.2**: Agent type shall be identified by `agent_id` string
- **REQ-1.3**: The interface shall support session management, messaging, and control operations

#### REQ-2: Agent Identification
- **REQ-2.1**: Each agent shall have a unique `agent_id` following pattern: `<type>.<provider>.<name>`
- **REQ-2.2**: Supported agent types:
  - `deepchat.*` - DeepChat built-in agents
  - `acp.*` - ACP protocol agents
- **REQ-2.3**: Agent registration shall be automatic on application startup

#### REQ-3: Unified Session Management
- **REQ-3.1**: All agents shall use `sessionId` as the unified session identifier
- **REQ-3.2**: For DeepChat agents, `sessionId` shall map to `conversationId` from SQLite
- **REQ-3.3**: For ACP agents, `sessionId` shall be generated by the agent
- **REQ-3.4**: The system shall provide `loadSession(sessionId)` with agent-specific implementations:
  - ACP: Triggers streaming history push from agent
  - DeepChat: Loads from SQLite

#### REQ-4: Unified Event System
- **REQ-4.1**: All agents shall emit events in the `AgenticEventType` format
- **REQ-4.2**: Events shall cover:
  - Session lifecycle (created, updated, closed)
  - Message flow (delta, block, end)
  - Tool calls (start, running, end)
  - Status changes and errors
- **REQ-4.3**: Event normalization shall happen internally within each presenter
- **REQ-4.4**: All agent events to renderer MUST be sent through `AgenticEventEmitter`
- **REQ-4.5**: Agents shall NOT call `eventBus.sendToRenderer()` directly with their native event types

#### REQ-5: Model and Mode Selection
- **REQ-5.1**: The interface shall provide `setModel(sessionId, modelId)` for model selection
- **REQ-5.2**: The interface shall provide `setMode(sessionId, modeId)` for mode/permission policy selection
- **REQ-5.3**: `modeId` shall come from `availableModes` array returned by the agent
- **REQ-5.4**: Model configuration (temperature, maxTokens, etc.) shall NOT be handled at this layer

#### REQ-6: Extensibility
- **REQ-6.1**: New agent types shall be added by implementing `IAgenticPresenter` protocol
- **REQ-6.2**: New agent types shall register via `agentic.registerAgent(presenter)`

### Non-Functional Requirements

#### NFR-1: Separation of Concerns
- Model configuration shall NOT be handled by this layer
- Permission policy implementation shall remain within each agent
- Persistence strategies shall remain agent-specific

#### NFR-2: Type Safety
- All interfaces shall be fully typed with TypeScript
- No `any` types shall be used in public interfaces

#### NFR-3: Backward Compatibility
- This is a green-field design; no migration path required
- Existing ACP and DeepChat presenters shall be refactored to implement the new protocol

## Data Models

### SessionInfo

```typescript
interface SessionInfo {
  sessionId: string
  agentId: string
  status: 'idle' | 'generating' | 'paused' | 'error'

  // Available modes = available permission policy options
  availableModes?: Array<{ id: string; name: string; description: string }>

  // Available models
  availableModels?: Array<{ id: string; name: string; description?: string }>

  // Current selection
  currentModeId?: string
  currentModelId?: string

  // Capability declarations
  capabilities: {
    supportsVision: boolean
    supportsTools: boolean
    supportsModes: boolean
  }
}
```

### MessageContent

```typescript
interface MessageContent {
  text?: string
  images?: Array<{ type: 'url' | 'base64' | 'file'; data: string }>
  files?: Array<{ path: string; name: string }>
}
```

### SessionConfig

```typescript
interface SessionConfig {
  modelId?: string
  modeId?: string
  // Additional agent-specific config
  [key: string]: any
}
```

### LoadContext

```typescript
interface LoadContext {
  maxHistory?: number
  includeSystemMessages?: boolean
}
```

## API Specification

### IAgenticPresenter Protocol

```typescript
interface IAgenticPresenter {
  readonly agentId: string

  // Session management
  createSession(config: SessionConfig): Promise<string>
  getSession(sessionId: string): SessionInfo | null
  loadSession(sessionId: string, context: LoadContext): Promise<void>
  closeSession(sessionId: string): Promise<void>

  // Messaging
  sendMessage(sessionId: string, content: MessageContent): Promise<void>

  // Control
  cancelMessage(sessionId: string, messageId: string): Promise<void>

  // Model/Mode selection
  setModel(sessionId: string, modelId: string): Promise<void>
  setMode(sessionId: string, modeId): Promise<void>
}
```

### AgenticEventType Enum

```typescript
enum AgenticEventType {
  // Session lifecycle
  SESSION_CREATED = 'agentic.session.created',
  SESSION_READY = 'agentic.session.ready',        // loadSession completed, messages loaded
  SESSION_UPDATED = 'agentic.session.updated',
  SESSION_CLOSED = 'agentic.session.closed',

  // Message flow
  MESSAGE_DELTA = 'agentic.message.delta',
  MESSAGE_BLOCK = 'agentic.message.block',
  MESSAGE_END = 'agentic.message.end',

  // Tool calls
  TOOL_START = 'agentic.tool.start',
  TOOL_RUNNING = 'agentic.tool.running',
  TOOL_END = 'agentic.tool.end',
  // Tool permission lifecycle (DeepChat agents)
  TOOL_PERMISSION_REQUIRED = 'agentic.tool.permission-required',
  TOOL_PERMISSION_GRANTED = 'agentic.tool.permission-granted',
  TOOL_PERMISSION_DENIED = 'agentic.tool.permission-denied',

  // Status
  STATUS_CHANGED = 'agentic.status.changed',
  ERROR = 'agentic.error',
}
```

## Event Payloads

### SESSION_CREATED

```typescript
interface SessionCreatedEvent {
  sessionId: string
  agentId: string
  sessionInfo: SessionInfo
}
```

### MESSAGE_DELTA

```typescript
interface MessageDeltaEvent {
  sessionId: string
  messageId: string
  content: string
  isComplete: boolean
}
```

### MESSAGE_BLOCK

```typescript
interface MessageBlockEvent {
  sessionId: string
  messageId: string
  blockType: 'text' | 'tool' | 'reasoning' | 'error' | 'image' | 'action' | 'search' | 'mcp_ui_resource'
  content: unknown
}
```

**Block Type Descriptions**:

| Block Type | Description | Source |
|-----------|-------------|--------|
| `text` | Text content delta | Both agents |
| `tool` | Tool call information | Both agents |
| `reasoning` | Reasoning/thinking content | DeepChat (extended thinking) |
| `error` | Error message | Both agents |
| `image` | Image data (base64 or URL) | DeepChat (vision) |
| `action` | Action block (permission request, max tool calls) | DeepChat |
| `search` | Search results from web search tools | DeepChat (MCP) |
| `mcp_ui_resource` | MCP UI resource (HTML, remote DOM) | DeepChat (MCP) |

### SESSION_READY

Emitted when `loadSession()` completes successfully. For ACP agents, this is emitted after the agent streams all history messages. For DeepChat agents, this is emitted after loading from SQLite.

```typescript
interface SessionReadyEvent {
  sessionId: string
  agentId: string
  messageCount?: number  // Number of messages loaded (ACP only)
}
```

### TOOL_START

```typescript
interface ToolStartEvent {
  sessionId: string
  toolId: string
  toolName: string
  arguments: Record<string, unknown>
}
```

### TOOL_RUNNING

```typescript
interface ToolRunningEvent {
  sessionId: string
  toolId: string
  status?: string  // Optional status message
}
```

### TOOL_END

```typescript
interface ToolEndEvent {
  sessionId: string
  toolId: string
  result?: unknown
  error?: Error
}
```

### TOOL_PERMISSION_REQUIRED

Emitted when a tool call requires user permission (DeepChat agents only).

```typescript
interface ToolPermissionRequiredEvent {
  sessionId: string
  toolId: string
  toolName: string
  request: {
    permissionType: 'read' | 'write' | 'all' | 'command'
    toolName?: string
    serverName?: string
    description?: string
    command?: string
    commandInfo?: {
      command: string
      riskLevel: 'low' | 'medium' | 'high' | 'critical'
      suggestion: string
      signature?: string
      baseCommand?: string
    }
    rememberable?: boolean
  }
}
```

### TOOL_PERMISSION_GRANTED

```typescript
interface ToolPermissionGrantedEvent {
  sessionId: string
  toolId: string
}
```

### TOOL_PERMISSION_DENIED

```typescript
interface ToolPermissionDeniedEvent {
  sessionId: string
  toolId: string
}
```

### STATUS_CHANGED

```typescript
interface StatusChangedEvent {
  sessionId: string
  status: 'idle' | 'generating' | 'paused' | 'error'
  error?: Error
}
```

## Unified Event Emission

### Problem Statement

Currently, each presenter sends events directly to the renderer using their native event types:

```typescript
// AgentPresenter - sends STREAM_EVENTS directly
eventBus.sendToRenderer(STREAM_EVENTS.RESPONSE, SendTarget.ALL_WINDOWS, payload)
eventBus.sendToRenderer(STREAM_EVENTS.END, SendTarget.ALL_WINDOWS, payload)

// AcpPresenter - sends ACP_EVENTS directly
eventBus.sendToRenderer(ACP_EVENTS.SESSION_UPDATE, SendTarget.ALL_WINDOWS, payload)
eventBus.sendToRenderer(ACP_EVENTS.PROMPT_COMPLETED, SendTarget.ALL_WINDOWS, payload)
```

This causes:
1. **Event leakage**: Native event types (`STREAM_EVENTS`, `ACP_EVENTS`) reach the renderer
2. **No centralization**: Events bypass the unified `AgenticPresenter` layer
3. **Normalizers unused**: Existing normalizer files are not integrated

### Solution: AgenticEventEmitter

`AgenticPresenter` provides a unified event emission mechanism that all agents MUST use:

```typescript
interface AgenticEventEmitter {
  // Message flow events
  messageDelta(messageId: string, content: string, isComplete: boolean): void
  messageEnd(messageId: string): void
  messageBlock(messageId: string, blockType: string, content: unknown): void

  // Tool call events
  toolStart(toolId: string, toolName: string, arguments: Record<string, unknown>): void
  toolRunning(toolId: string, status?: string): void
  toolEnd(toolId: string, result?: unknown, error?: Error): void

  // Tool permission lifecycle (DeepChat agents)
  toolPermissionRequired(
    toolId: string,
    toolName: string,
    request: PermissionRequestPayload
  ): void
  toolPermissionGranted(toolId: string): void
  toolPermissionDenied(toolId: string): void

  // Session lifecycle events (for internal use by presenters)
  sessionReady(sessionId: string, messageCount?: number): void
  sessionUpdated(info: Partial<SessionInfo>): void

  // Status events
  statusChanged(status: 'idle' | 'generating' | 'paused' | 'error', error?: Error): void
}

// Permission request payload (shared between agents)
interface PermissionRequestPayload {
  permissionType: 'read' | 'write' | 'all' | 'command'
  toolName?: string
  serverName?: string
  description?: string
  command?: string
  commandInfo?: {
    command: string
    riskLevel: 'low' | 'medium' | 'high' | 'critical'
    suggestion: string
    signature?: string
    baseCommand?: string
  }
  providerId?: string
  requestId?: string
  sessionId?: string
  agentId?: string
  agentName?: string
  conversationId?: string
  rememberable?: boolean
}
```

### AgenticPresenter Event Emission API

```typescript
class AgenticPresenter {
  /**
   * Create an event emitter for a specific session
   * Agents use this to send all events for a session
   */
  createEventEmitter(sessionId: string): AgenticEventEmitter

  /**
   * Low-level event emitter (for special cases)
   * Normalizers use this to emit normalized events
   */
  emitAgenticEvent(
    eventType: AgenticEventType,
    sessionId: string,
    payload: unknown
  ): void
}
```

### Event Flow Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    AgentPresenter / AcpPresenter                │
│                                                                  │
│  Internal streaming receives native events:                      │
│  - STREAM_EVENTS.RESPONSE (AgentPresenter)                      │
│  - ACP_EVENTS.SESSION_UPDATE (AcpPresenter)                     │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │   Normalizer    │  ← Converts native → AgenticEventType
                    └────────┬────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │   AgenticEvent  │  ← Type-safe emitter methods
                    │    Emitter      │
                    └────────┬────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                       AgenticPresenter                          │
│                                                                  │
│  emitAgenticEvent(eventType, sessionId, payload)                │
│         │                                                        │
│         ▼                                                        │
│  eventBus.sendToRenderer(AgenticEventType, ...)                 │
└────────────────────────────┬────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Renderer Process                           │
│                                                                  │
│  Listens ONLY to AgenticEventType events                        │
└─────────────────────────────────────────────────────────────────┘
```

### Usage Pattern

```typescript
// AgentPresenter sends messages
class AgentPresenter implements IAgenticPresenter {
  async sendMessage(sessionId: string, content: MessageContent): Promise<void> {
    // Get unified emitter from AgenticPresenter
    const emitter = agenticPresenter.createEventEmitter(sessionId)

    // Stream response
    for await (const chunk of this.streamResponse(content)) {
      // Use emitter - no direct eventBus calls!
      emitter.messageDelta(messageId, chunk.content, chunk.isComplete)
    }

    emitter.messageEnd(messageId)
  }
}

// AcpPresenter sends tool call events
class AcpPresenter implements IAgenticPresenter {
  async handleToolCall(sessionId: string, toolCall: ToolCall): Promise<void> {
    const emitter = agenticPresenter.createEventEmitter(sessionId)

    emitter.toolStart(toolCall.id, toolCall.name, toolCall.arguments)

    try {
      const result = await this.executeTool(toolCall)
      emitter.toolEnd(toolCall.id, result)
    } catch (error) {
      emitter.toolEnd(toolCall.id, undefined, error)
    }
  }
}
```

### Normalizer Integration

Each presenter's normalizer integrates with the emitter:

```typescript
// agentPresenter/normalizer.ts
export function normalizeAndEmit(
  nativeEvent: STREAM_EVENTS,
  sessionId: string,
  emitter: AgenticEventEmitter
): void {
  switch (nativeEvent.type) {
    case STREAM_EVENTS.RESPONSE:
      emitter.messageDelta(
        nativeEvent.messageId,
        nativeEvent.content,
        nativeEvent.isComplete
      )
      break
    case STREAM_EVENTS.END:
      emitter.messageEnd(nativeEvent.messageId)
      break
    // ... other mappings
  }
}

// acpPresenter/normalizer.ts
export function normalizeAndEmit(
  nativeEvent: ACP_EVENTS,
  sessionId: string,
  emitter: AgenticEventEmitter
): void {
  switch (nativeEvent.type) {
    case ACP_EVENTS.SESSION_UPDATE:
      emitter.messageDelta(
        nativeEvent.messageId,
        nativeEvent.content,
        nativeEvent.isComplete
      )
      break
    case ACP_EVENTS.PROMPT_COMPLETED:
      emitter.messageEnd(nativeEvent.messageId)
      break
    // ... other mappings
  }
}
```

## Architecture Constraints

### What This Layer Handles

| Feature | Scope |
|---------|-------|
| **Model Management** | Model ID selection only |
| **Mode Management** | Permission policy selection via `setMode(modeId)` |
| **History Loading** | Unified `loadSession` interface |
| **Agent Routing** | `agent_id` to Presenter mapping |

### What This Layer Does NOT Handle

| Feature | Responsibility |
|---------|---------------|
| **Model Configuration** | temperature, maxTokens, topP - handled by each agent |
| **Permission Policy Implementation** | Specific request handling - agent internal |
| **Persistence Strategy** | ACP streaming vs DeepChat SQLite - agent specific |
| **Session Storage** | DeepChat SQLite storage - AgentPresenter internal |

## Success Criteria

1. Renderer can interact with any agent using only `AgenticPresenter`
2. All agents emit events in `AgenticEventType` format
3. New agent types can be added without modifying renderer code
4. Type safety maintained throughout the stack
5. Existing ACP and DeepChat functionality preserved

## Open Questions

### [RESOLVED] Agent ID Format
**Question**: What format should `agent_id` use?

**Resolution**: Use hierarchical format `<type>.<provider>.<name>`
- Examples: `deepchat.default`, `acp.anthropic.claude-code`

### [RESOLVED] DeepChat Agent Modes
**Question**: What should `availableModes` contain for DeepChat agents?

**Resolution**: For DeepChat agents, `setMode` controls the **permission policy** (default permission judgment logic). The available modes are:

| Mode ID | Name | Description |
|---------|------|-------------|
| `strict` | Strict | All operations require user confirmation |
| `balanced` | Balanced | Read operations auto-allow, write/delete require confirmation |
| `permissive` | Permissive | Most operations auto-allow, only dangerous operations require confirmation |

**Design Notes**:
- `setMode(sessionId, modeId)` sets the session-level permission policy
- This affects how permission requests are handled for the entire session
- For example: in `balanced` mode, file read operations may be auto-approved, but file writes still prompt the user
- No per-tool remember mechanism exists (ACP agents have their own internal handling)
- Future extension: True "execution modes" (like ACP's plan/act) may be added later

### [RESOLVED] Event Normalization Approach
**Question**: Should we have a centralized EventNormalizer?

**Resolution**: No - each Presenter handles its own event conversion internally
- AgentPresenter: `STREAM_EVENTS` → `AgenticEventType`
- AcpPresenter: `ACP_EVENTS` → `AgenticEventType`

## Dependencies

### Internal Dependencies
- `src/main/presenter/agentPresenter/` - Must implement `IAgenticPresenter`
- `src/main/presenter/acpPresenter/` - Must implement `IAgenticPresenter`
- `src/main/eventbus.ts` - For unified event emission

### External Dependencies
- None (pure architecture layer)

## Related Documents

- Architecture: `docs/architecture/agent-abstraction-layer.md`
- Implementation Plan: `docs/specs/agentic-unified-layer/plan.md`
- Task Breakdown: `docs/specs/agentic-unified-layer/tasks.md`
