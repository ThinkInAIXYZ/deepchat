<template>
  <div
    class="flex flex-row h-9 min-h-9 bg-window-background border border-b-0 border-window-inner-border box-border rounded-t-[10px] relative overflow-hidden"
    :class="[!isFullscreened && isMacOS ? '' : ' rounded-t-none']"
    :dir="langStore.dir"
  >
    <div class="absolute bottom-0 left-0 w-full h-[1px] bg-border"></div>
    <div
      class="h-full shrink-0 w-0 flex-1 flex select-none text-center text-sm font-medium flex-row items-center justify-start window-drag-region"
    >
      <div v-if="!isFullscreened && isMacOS" class="shrink-0 w-20 h-full window-drag-region"></div>
      <!-- App title/content in center -->
      <Button
        v-if="isTabContainerOverflowingLeft"
        variant="ghost"
        class="window-no-drag-region shrink-0 w-10 bg-transparent shadow-none rounded-none hover:bg-bg-card/80 text-xs font-medium text-foreground flex items-center justify-center transition-all duration-200 group border-r border-border"
        @click="scrollTabContainer('left')"
      >
        <Icon icon="lucide:chevron-left" class="w-4 h-4" />
      </Button>
      <Button
        v-if="isTabContainerOverflowingRight"
        variant="ghost"
        class="window-no-drag-region shrink-0 w-10 bg-transparent shadow-none rounded-none hover:bg-bg-card/80 text-xs font-medium text-foreground flex items-center justify-center transition-all duration-200 group border-border"
        @click="scrollTabContainer('right')"
      >
        <Icon icon="lucide:chevron-right" class="w-4 h-4" />
      </Button>
      <div
        ref="tabContainerWrapper"
        class="h-full self-stretch inline-flex flex-row items-center justify-start overflow-y-hidden overflow-x-auto scrollbar-hide"
        @scroll="onTabContainerWrapperScroll"
      >
        <div
          ref="tabContainer"
          class="h-full flex flex-row items-center justify-start relative"
          @dragover="onTabContainerDragOver"
          @drop="onTabContainerDrop"
        >
          <AppBarTabItem
            v-for="(tab, idx) in tabStore.tabs"
            :key="tab.id"
            :active="tab.id === tabStore.currentTabId"
            :size="tabStore.tabs.length"
            :index="idx"
            class="window-no-drag-region"
            @click="tabStore.setCurrentTabId(tab.id)"
            @close="tabStore.removeTab(tab.id)"
            @dragstart="onTabDragStart(tab.id, $event)"
            @dragover="onTabItemDragOver(idx, $event)"
          >
            <img src="@/assets/logo.png" class="w-4 h-4 mr-2 rounded-sm" />
            <span class="truncate">{{ tab.title ?? 'DeepChat' }}</span>
          </AppBarTabItem>
          <!-- 拖拽插入指示器 -->
          <div
            v-if="dragInsertIndex !== -1"
            class="absolute top-0 bottom-0 w-0.5 bg-blue-500 z-10 pointer-events-none"
            :style="{ left: dragInsertPosition + 'px' }"
          ></div>
          <div ref="endOfTabs" class="w-0 shrink-0 h-full"></div>
        </div>
      </div>

      <Button
        size="icon"
        class="window-no-drag-region shrink-0 w-10 bg-transparent shadow-none rounded-none hover:bg-bg-card/80 text-xs font-medium text-foreground flex items-center justify-center transition-all duration-200 group"
        @click="onNewTabClick"
      >
        <Icon icon="lucide:plus" class="w-4 h-4" />
      </Button>
      <div class="flex-1"></div>

      <Button
        size="icon"
        class="window-no-drag-region shrink-0 w-10 bg-transparent shadow-none rounded-none hover:bg-bg-card/80 text-xs font-medium text-foreground flex items-center justify-center transition-all duration-200 group"
        @click="onHistoryClick"
      >
        <Icon icon="lucide:history" class="w-4 h-4" />
      </Button>
      <Button
        variant="ghost"
        class="window-no-drag-region shrink-0 w-10 bg-transparent shadow-none rounded-none hover:bg-bg-card/80 text-xs font-medium text-foreground flex items-center justify-center transition-all duration-200 group"
        @click="openSettings"
      >
        <Icon icon="lucide:ellipsis" class="w-4 h-4" />
      </Button>
      <Button
        v-if="!isMacOS"
        class="window-no-drag-region shrink-0 w-12 bg-transparent shadow-none rounded-none hover:bg-bg-card/80 text-xs font-medium text-foreground flex items-center justify-center transition-all duration-200 group"
        @click="minimizeWindow"
      >
        <MinimizeIcon class="h-3! w-3!" />
      </Button>
      <Button
        v-if="!isMacOS"
        class="window-no-drag-region shrink-0 w-12 bg-transparent shadow-none rounded-none hover:bg-bg-card/80 text-xs font-medium text-foreground flex items-center justify-center transition-all duration-200 group"
        @click="toggleMaximize"
      >
        <MaximizeIcon v-if="!isMaximized" class="h-3! w-3!" />
        <RestoreIcon v-else class="h-3! w-3!" />
      </Button>
      <Button
        v-if="!isMacOS"
        class="window-no-drag-region shrink-0 w-12 bg-transparent shadow-none rounded-none hover:bg-bg-card/80 text-xs font-medium text-foreground flex items-center justify-center transition-all duration-200 group"
        @click="closeWindow"
      >
        <CloseIcon class="h-3! w-3!" />
      </Button>

      <!-- <Button
        class="text-xs font-medium px-2 h-7 bg-transparent rounded-md flex items-center justify-center"
        @click="openNewWindow"
      >
        <Icon v-if="isMacOS" icon="lucide:app-window-mac" class="w-4 h-4" />
        <Icon v-else icon="lucide:app-window" class="w-4 h-4" />
      </Button> -->
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, nextTick, computed } from 'vue'
import MaximizeIcon from './icons/MaximizeIcon.vue'
import RestoreIcon from './icons/RestoreIcon.vue'
import { usePresenter } from '@/composables/usePresenter'
import { Button } from '@shadcn/components/ui/button'
import { Icon } from '@iconify/vue'
import AppBarTabItem from './app-bar/AppBarTabItem.vue'
import { useTabStore } from '@shell/stores/tab'
import { useElementSize } from '@vueuse/core'
import { useLanguageStore } from '@/stores/language'
import { useI18n } from 'vue-i18n'
import { WINDOW_EVENTS } from '../lib/events'
import CloseIcon from './icons/CloseIcon.vue'
import MinimizeIcon from './icons/MinimizeIcon.vue'
import { THREAD_VIEW_EVENTS } from '@/events'
const tabStore = useTabStore()
const langStore = useLanguageStore()
const windowPresenter = usePresenter('windowPresenter')
const devicePresenter = usePresenter('devicePresenter')
const tabPresenter = usePresenter('tabPresenter')
const endOfTabs = ref<HTMLElement | null>(null)

const { t } = useI18n()

const isMacOS = ref(false)
const isMaximized = ref(false)
const isFullscreened = ref(false)

const { ipcRenderer } = window.electron

const tabContainerWrapper = ref<HTMLElement | null>(null)
const tabContainer = ref<HTMLElement | null>(null)

let draggedTabId: number | null = null
const dragInsertIndex = ref(-1)
const dragInsertPosition = ref(0)

const tabContainerWrapperSize = useElementSize(tabContainerWrapper)
const tabContainerSize = useElementSize(tabContainer)
const tabContainerWrapperScrollLeft = ref(0)

const onTabContainerWrapperScroll = () => {
  requestAnimationFrame(() => {
    tabContainerWrapperScrollLeft.value = tabContainerWrapper.value?.scrollLeft ?? 0
  })
}

const onHistoryClick = async () => {
  try {
    const windowId = window.api.getWindowId()
    if (windowId == null) {
      console.warn('Failed to toggle thread view: unable to determine window id.')
      return
    }
    const success = await windowPresenter.sendToActiveTab(windowId, THREAD_VIEW_EVENTS.TOGGLE)
    if (!success) {
      console.warn('Failed to toggle thread view: no active tab found.')
    }
  } catch (error) {
    console.warn('Failed to toggle thread view via windowPresenter.', error)
  }
}

const isTabContainerOverflowingLeft = computed(() => {
  return (
    tabContainerWrapperSize.width.value < tabContainerSize.width.value &&
    tabContainerWrapperScrollLeft.value > 0
  )
})

const isTabContainerOverflowingRight = computed(() => {
  return (
    tabContainerWrapperSize.width.value < tabContainerSize.width.value &&
    tabContainerWrapperScrollLeft.value <
      (tabContainerWrapper.value?.scrollWidth ?? 0) - tabContainerWrapperSize.width.value
  )
})

const onTabDragStart = (tabId: number, event: DragEvent) => {
  const tab = tabStore.tabs.find((t) => t.id === tabId)
  if (!tab) {
    console.warn(`Tab with id ${tabId} not found for drag start.`)
    return
  }

  if (event.dataTransfer) {
    event.dataTransfer.setData('text/plain', tabId.toString())
    event.dataTransfer.effectAllowed = 'all' // 允许所有拖拽效果，动态判断
    draggedTabId = tabId
    console.log('onTabDragStart - Tab ID:', tabId, 'Name:', tab.title)

    // Create the drag preview element
    const preview = document.createElement('div')
    preview.style.position = 'absolute'
    preview.style.top = '-1000px'
    preview.style.left = '-1000px'
    preview.style.backgroundColor = 'hsl(var(--background))'
    preview.style.color = 'hsl(var(--foreground))'
    preview.style.border = `1px solid hsl(var(--border))`
    preview.style.borderRadius = '6px'
    preview.style.padding = '48px'
    preview.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1), 0 4px 8px rgba(0,0,0,0.1)'
    preview.style.fontSize = '13px'
    preview.style.fontFamily = 'inherit'
    preview.style.display = 'inline-block'
    preview.style.whiteSpace = 'nowrap'
    preview.style.zIndex = '9999'

    preview.textContent = tab.title || 'Untitled Tab'

    document.body.appendChild(preview)
    event.dataTransfer.setDragImage(preview, 10, 10)

    setTimeout(() => {
      if (preview.parentNode === document.body) {
        document.body.removeChild(preview)
      }
    }, 0)
  }
}

// 标签页项目拖拽悬停处理（窗口内重排序）
const onTabItemDragOver = (index: number, event: DragEvent) => {
  event.preventDefault()
  event.stopPropagation()

  // 检查是否是当前窗口的标签页拖拽
  const isCurrentWindowDrag = draggedTabId !== null
  // 检查是否是外部拖拽（跨窗口）
  const isExternalDrag = !isCurrentWindowDrag && event.dataTransfer?.types.includes('text/plain')

  if (!isCurrentWindowDrag && !isExternalDrag) return

  // 窗口内拖拽使用 move
  if (event.dataTransfer) {
    event.dataTransfer.dropEffect = 'move'
  }

  // 计算插入位置
  const tabElement = event.currentTarget as HTMLElement
  const rect = tabElement.getBoundingClientRect()
  const containerRect = tabContainer.value?.getBoundingClientRect()

  if (containerRect) {
    const mouseX = event.clientX
    const tabCenterX = rect.left + rect.width / 2

    // 判断插入到左侧还是右侧
    if (mouseX < tabCenterX) {
      dragInsertIndex.value = index
      dragInsertPosition.value = rect.left - containerRect.left
    } else {
      dragInsertIndex.value = index + 1
      dragInsertPosition.value = rect.right - containerRect.left
    }
  }
}

// 标签页容器拖拽悬停处理
const onTabContainerDragOver = (event: DragEvent) => {
  // 检查是否是当前窗口的标签页拖拽或外部拖拽
  const isCurrentWindowDrag = draggedTabId !== null
  const isExternalDrag = !isCurrentWindowDrag && event.dataTransfer?.types.includes('text/plain')

  if (!isCurrentWindowDrag && !isExternalDrag) return

  event.preventDefault()
  // 设置正确的 dropEffect 以支持窗口内拖拽
  if (event.dataTransfer) {
    event.dataTransfer.dropEffect = 'move'
  }
}

// 标签页容器放置处理（窗口内重排序和跨窗口拖拽）
const onTabContainerDrop = async (event: DragEvent) => {
  event.preventDefault()

  // Helper to reset drag state
  const resetDragState = () => {
    dragInsertIndex.value = -1
    dragInsertPosition.value = 0
  }

  if (dragInsertIndex.value === -1) {
    resetDragState()
    return
  }

  // 获取拖拽的标签页ID
  const draggedTabIdFromEvent = event.dataTransfer?.getData('text/plain')
  const finalDraggedTabId =
    draggedTabId || (draggedTabIdFromEvent ? parseInt(draggedTabIdFromEvent) : null)

  if (!finalDraggedTabId) {
    resetDragState()
    return
  }

  const currentWindowId = window.api.getWindowId()
  if (!currentWindowId) {
    resetDragState()
    return
  }

  try {
    // 检查是否是当前窗口的标签页
    const isFromCurrentWindow = tabStore.tabs.some((tab) => tab.id === finalDraggedTabId)

    if (isFromCurrentWindow) {
      // 窗口内重排序
      const draggedTabIndex = tabStore.tabs.findIndex((tab) => tab.id === finalDraggedTabId)
      if (draggedTabIndex === -1) {
        resetDragState()
        return
      }

      let targetIndex = dragInsertIndex.value

      // 如果拖拽到原位置，不需要重排序
      if (targetIndex === draggedTabIndex || targetIndex === draggedTabIndex + 1) {
        resetDragState()
        return
      }

      // 调整目标索引（如果拖拽到后面的位置，需要减1）
      if (targetIndex > draggedTabIndex) {
        targetIndex -= 1
      }

      // 创建新的标签页顺序
      const newTabs = [...tabStore.tabs]
      const [draggedTab] = newTabs.splice(draggedTabIndex, 1)
      newTabs.splice(targetIndex, 0, draggedTab)

      // 调用后端重排序方法，同步到主进程
      const newTabIds = newTabs.map((tab) => tab.id)
      const success = await tabStore.reorderTabs(newTabIds)
      if (!success) {
        console.error('Failed to reorder tabs')
      }
    } else {
      // 跨窗口拖拽
      console.log(
        'Cross-window drag detected:',
        finalDraggedTabId,
        'to window:',
        currentWindowId,
        'at index:',
        dragInsertIndex.value
      )

      // 调用主进程的 moveTab 方法
      const success = await tabPresenter.moveTab(
        finalDraggedTabId,
        currentWindowId,
        dragInsertIndex.value
      )
      if (success) {
        console.log('Tab moved successfully')
      } else {
        console.error('Failed to move tab')
      }
    }
  } catch (error) {
    console.error('Error during tab drop operation:', error)
  } finally {
    resetDragState()
  }
}

const handleDragOver = (event: DragEvent) => {
  // 只处理当前窗口的标签页拖拽
  if (!draggedTabId) return

  // 检查鼠标是否在标签页容器区域内
  const containerRect = tabContainer.value?.getBoundingClientRect()
  if (containerRect) {
    const isOverTabContainer =
      event.clientX >= containerRect.left &&
      event.clientX <= containerRect.right &&
      event.clientY >= containerRect.top &&
      event.clientY <= containerRect.bottom

    if (isOverTabContainer) {
      // 在标签页区域内，允许拖拽
      event.preventDefault()
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = 'move'
      }
    } else {
      // 在标签页区域外，设置为 none 以支持拖拽到窗口外
      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = 'none'
      }
    }
  }
}

const handleDragEnd = async (event: DragEvent) => {
  console.log(
    'handleDragEnd',
    event.clientX,
    event.clientY,
    window.innerWidth,
    window.innerHeight,
    'dropEffect:',
    event.dataTransfer?.dropEffect
  )

  // 清理拖拽状态
  dragInsertIndex.value = -1

  if (tabStore.tabs.length <= 1) {
    event.preventDefault()
    draggedTabId = null
    return
  }

  // 检查是否拖拽到窗口外创建新窗口
  // 当 dropEffect 为 'none' 时，说明没有有效的放置目标
  if (draggedTabId && event.dataTransfer?.dropEffect === 'none') {
    // Check if the mouse is outside the window bounds or in non-droppable area
    const isOutsideWindow =
      event.clientX <= 0 ||
      event.clientY <= 0 ||
      event.clientX >= window.innerWidth ||
      event.clientY >= window.innerHeight

    if (isOutsideWindow) {
      console.log('Tab dragged outside window:', draggedTabId)
      // Call main process to move tab to new window
      await tabPresenter.moveTabToNewWindow(draggedTabId, event.clientX, event.clientY)
    }
  }
  draggedTabId = null
}

// const onThemeClick = () => {
//   console.log('onThemeClick')
//   themeStore.cycleTheme()
// }

onMounted(() => {
  console.log('onMounted', tabStore.tabs)
  // Listen for window maximize/unmaximize events
  devicePresenter.getDeviceInfo().then((deviceInfo) => {
    isMacOS.value = deviceInfo.platform === 'darwin'
  })
  ipcRenderer?.on(WINDOW_EVENTS.WINDOW_MAXIMIZED, () => {
    isMaximized.value = true
  })
  ipcRenderer?.on(WINDOW_EVENTS.WINDOW_ENTER_FULL_SCREEN, () => {
    isFullscreened.value = true
  })
  ipcRenderer?.on(WINDOW_EVENTS.WINDOW_UNMAXIMIZED, () => {
    isMaximized.value = false
  })
  ipcRenderer?.on(WINDOW_EVENTS.WINDOW_LEAVE_FULL_SCREEN, () => {
    isFullscreened.value = false
  })

  window.addEventListener('dragover', handleDragOver)
  window.addEventListener('dragend', handleDragEnd)
})

const isPlaygroundEnabled = import.meta.env.VITE_ENABLE_PLAYGROUND === 'true'

const openNewTab = (event?: MouseEvent, forcePlayground = false) => {
  const shouldOpenPlayground = isPlaygroundEnabled && (forcePlayground || event?.shiftKey)

  const config = shouldOpenPlayground
    ? {
        name: t('routes.playground'),
        icon: 'lucide:flask-conical',
        viewType: 'playground'
      }
    : {
        name: t('common.newTab'),
        icon: 'lucide:plus',
        viewType: 'chat'
      }

  tabStore.addTab(config)
  setTimeout(() => {
    nextTick(() => {
      if (endOfTabs.value) {
        console.log('newTabButton', endOfTabs.value)
        endOfTabs.value.scrollIntoView({ behavior: 'smooth', block: 'center' })
      }
    })
  }, 300)
}

const onNewTabClick = (event: MouseEvent) => {
  openNewTab(event)
}

const scrollTabContainer = (direction: 'left' | 'right') => {
  if (tabContainerWrapper.value) {
    tabContainerWrapper.value.scrollTo({
      left: tabContainerWrapper.value.scrollLeft + (direction === 'left' ? -100 : 100),
      behavior: 'smooth'
    })
  }
}

// const openNewWindow = () => {
//   windowPresenter.createShellWindow({
//     initialTab: {
//       url: 'local://chat'
//     }
//   })
// }

const minimizeWindow = () => {
  const id = window.api.getWindowId()
  if (id != null) {
    windowPresenter.minimize(id)
  }
}

const toggleMaximize = () => {
  const id = window.api.getWindowId()
  if (id != null) {
    windowPresenter.maximize(id)
  }
}

const closeWindow = () => {
  const id = window.api.getWindowId()
  if (id != null) {
    windowPresenter.close(id)
  }
}

const openSettings = () => {
  const windowId = window.api.getWindowId()
  if (windowId != null) {
    windowPresenter.openOrFocusSettingsTab(windowId)
  }
}
</script>

<style scoped>
.window-drag-region {
  -webkit-app-region: drag;
}

.window-no-drag-region {
  -webkit-app-region: no-drag;
}

button {
  -webkit-app-region: no-drag;
}

/* For Webkit-based browsers (Chrome, Safari, newer versions of Edge) */
.overflow-x-auto::-webkit-scrollbar {
  height: 4px;
  /* Adjust as needed for thickness */
}

.overflow-x-auto::-webkit-scrollbar-track {
  background: transparent;
  /* Or a very subtle color like #f1f1f1 or theme background */
}

.overflow-x-auto::-webkit-scrollbar-thumb {
  background: #a1a1aa;
  /* Scrollbar thumb color - zinc-400 */
  border-radius: 2px;
  /* Rounded corners for the thumb */
}

.overflow-x-auto::-webkit-scrollbar-thumb:hover {
  background: #71717a;
  /* Scrollbar thumb color on hover - zinc-500 */
}

/* For Firefox - already handled by inline style for simplicity, can also be moved here */
/*
.overflow-x-auto {
  scrollbar-width: thin;
  scrollbar-color: #a1a1aa transparent;
}
*/
</style>
